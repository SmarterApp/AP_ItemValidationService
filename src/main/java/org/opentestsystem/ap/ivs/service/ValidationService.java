package org.opentestsystem.ap.ivs.service;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.opentestsystem.ap.common.assembler.AppAssembler;
import org.opentestsystem.ap.common.client.GitClient;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.itembank.IdGenerator;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemContext;
import org.opentestsystem.ap.common.model.PreviewData;
import org.opentestsystem.ap.common.model.ValidationResult;
import org.opentestsystem.ap.common.model.ValidationResults;
import org.opentestsystem.ap.common.repository.RepositoryUtil;
import org.opentestsystem.ap.common.util.RandomIdGenerator;
import org.opentestsystem.ap.common.security.SecurityUtil;
import org.opentestsystem.ap.common.validation.ValidationManager;
import org.opentestsystem.ap.ivs.IvsProperties;
import org.opentestsystem.ap.ivs.models.ErrorReport;
import org.springframework.stereotype.Component;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import static org.apache.commons.collections4.ListUtils.emptyIfNull;

/**
 * Pulls validation requests from the message broker.
 */
@Slf4j
@Component
public class ValidationService {

    public static final IdGenerator ID_DIGIT_GENERATOR = new RandomIdGenerator(100000, Integer.MAX_VALUE);

    private final ValidationManager validationManager;

    private final IvsProperties ivsProperties;

    private final SecurityUtil securityUtil;

    private final ValidationUtility validationUtility;

    private final AppAssembler appAssembler;

    private final Path localBaseDir;

    public ValidationService(ValidationManager validationManager,
                             final IvsProperties ivsProperties,
                             final SecurityUtil securityUtil,
                             final ValidationUtility validationUtility,
                             final AppAssembler appAssembler,
                             final ItemBankProperties itemBankProperties) {
        this.validationManager = validationManager;
        this.ivsProperties = ivsProperties;
        this.securityUtil = securityUtil;
        this.validationUtility = validationUtility;
        this.appAssembler = appAssembler;
        this.localBaseDir = Paths.get(itemBankProperties.getLocalBaseDir());
    }

    // ------------------------------------------------------------------------

    public ValidationResults validateItem(final String itemId) {
        log.debug("validateItem: item {}", itemId);

        final ValidationResults result = new ValidationResults();

        GitClient gitClient = null;
        try {
            final Path validationPath = downloadData(itemId);
            runValidation(itemId, validationPath);

            List<ValidationResult> validationResults = generateResults(validationPath.getParent());

            RepositoryUtil.deleteDirectory(validationPath.getParent());

            ValidationResult syncResult = this.validationManager.generateSyncResult(itemId);

            if (Objects.nonNull(syncResult)) {
                validationResults.add(0, syncResult);
            }

            result.setValidationResults(emptyIfNull(validationResults));
        } finally {
            close(gitClient);
        }
        return result;
    }

    public List<ValidationResult> generateResults(final Path reportPath) {
        final List<ErrorReport> errors = validationUtility.parseErrorReport(reportPath);

        final Set<ValidationResult> errorsWithNoDups = errors.stream()
            .skip(1)
            .filter(error ->
                !StringUtils.equalsAnyIgnoreCase(
                    error.getCategory(), ivsProperties.getExcludedCategories().toArray(new String[0])))
            .map(this::mapErrorToResult)
            .collect(Collectors.toSet());

        return new ArrayList<>(errorsWithNoDups);
    }

    // ------------------------------------------------------------------------

    private ValidationResult mapErrorToResult(final ErrorReport error) {
        final ValidationResult result = new ValidationResult();
        result.setItemId(error.getItemId());
        result.setItemType(error.getItemType());
        result.setCategory(error.getCategory());
        result.setDetail(error.getDetail());
        result.setMessage(error.getErrorMessage());
        result.setSeverity(error.getSeverity());
        return result;
    }

    private Path downloadData(final String itemId) {
        PreviewData previewData = this.validationManager.generatePreviewData(securityUtil.getItemBankUser(), itemId);

        // could be stimulus or assessment item
        ItemContext itemContext = new ItemContext(
            itemId,
            previewData.getLegacyItemId(),
            previewData.getBankKey(),
            this.appAssembler,
            previewData.getRepositoryPath()
        );

        validationUtility.deleteGlossaryDirectory(itemContext);

        ItemContext stimulusContext = null;

        if (Objects.nonNull(previewData.getStimulusId())) {
            stimulusContext = new ItemContext(
                previewData.getStimulusId(),
                previewData.getLegacyStimulusId(),
                previewData.getBankKey(),
                this.appAssembler,
                previewData.getRepositoryPath().getParent().resolve(previewData.getLegacyStimulusId())
            );
        }

        return mapToValidationStructure(itemContext, stimulusContext);
    }

    /**
     * Shells out and runs the Content Package Tabulator in Error-Only mode to produce a validation.json file for the
     * indicated item.
     *
     * @param itemId The ID of the item to be validated
     * @param path   The path to the folder containing the item
     */
    public void runValidation(String itemId, Path path) {
        log.debug("runValidation: CPT validation for {} in path {}", itemId, path);

        final String command = String.format("%s %s", ivsProperties.getCptExecutablePath(), path.toString());

        BufferedReader stdInput = null;
        try {
            final Process process = Runtime.getRuntime().exec(command);
            logValidationOutput(process);
        } catch (SystemException e) {
            throw e;
        } catch (Exception e) {
            throw new SystemException(e);
        } finally {
            IOUtils.closeQuietly(stdInput);
        }
    }

    // ------------------------------------------------------------------------
    // Helper Methods
    // ------------------------------------------------------------------------

    private Path mapToValidationStructure(final ItemContext itemContext, final ItemContext stimulusContext) {
        // random folder, root for the validation request
        final Path validationRootPath = localBaseDir.resolve(ID_DIGIT_GENERATOR.generateTransactionId());
        // root folder has a child folder, typically called 'validation'
        final Path validationRootChild = validationUtility.initializeValidationStructure(validationRootPath);

        // are we dealing with a stim validation request or a assessment item validation request
        final Item item = itemContext.readModelFile();

        // the request is to validate a stimulus
        if (item.isStimulus()) {
            // maps to "root/validation/Stimuli"
            mapStimulusToValidationStructure(itemContext, validationRootChild);
        } else if (item.isTutorial()) {
            // maps to "root/validation/Items"
            mapTutorialToValidationStructure(itemContext, validationRootChild);
        } else {
            // maps to "root/validation/Items"
            mapItemToValidationStructure(itemContext, validationRootChild);
            // downloadData the item's associated stimulus
            validationUtility.deleteGlossaryDirectory(stimulusContext);
            mapStimulusToValidationStructure(stimulusContext, validationRootChild);
        }

        // clean up immediately, don't wait for cleanup task every few minutes, when
        // validation usage spikes waiting for the cleanup task is not enough, the disk
        // still fills up and the pod is evicted
        RepositoryUtil.deleteDirectory(itemContext.getLocalRepositoryPath().getParent());

        return validationRootChild;
    }

    private void mapItemToValidationStructure(final ItemContext itemContext, final Path validationRootChild) {
        validationUtility.mapItemToValidationStructure(itemContext, validationRootChild);
        validationUtility.mapGlossaryToValidationStructure(itemContext, validationRootChild);
    }

    private void mapStimulusToValidationStructure(final ItemContext stimulusContext, final Path validationRootChild) {
        validationUtility.mapStimulusToValidationStructure(stimulusContext, validationRootChild);
        // glossary maps to "root/validation/Items", not "Stimuli"
        validationUtility.mapGlossaryToValidationStructure(stimulusContext, validationRootChild);
    }

    private void mapTutorialToValidationStructure(final ItemContext tutorialContext, final Path validationRootChild) {
        validationUtility.mapItemToValidationStructure(tutorialContext, validationRootChild);
    }

    private void close(GitClient gitClient) {
        if (gitClient != null) {
            gitClient.close();
        }
    }

    private void logValidationOutput(final Process process) {
        final BufferedReader stdInput = new BufferedReader(new InputStreamReader(process.getInputStream()));
        String s;
        try {
            while ((s = stdInput.readLine()) != null) {
                log.debug("CPT: {}", s);
            }
        } catch (IOException e) {
            log.warn("logValidationOutput: Error logging validation output.", e);
        }
    }
}
