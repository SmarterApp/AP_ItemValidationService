package org.opentestsystem.ap.ivs.service;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.opentestsystem.ap.common.client.GitClient;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.itembank.IdGenerator;
import org.opentestsystem.ap.common.model.AssessmentItem;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemBankUser;
import org.opentestsystem.ap.common.model.ItemContext;
import org.opentestsystem.ap.common.model.ValidationResult;
import org.opentestsystem.ap.common.model.ValidationResults;
import org.opentestsystem.ap.common.repository.ItemCrudRequest;
import org.opentestsystem.ap.common.repository.ItemRepository;
import org.opentestsystem.ap.common.util.RandomIdGenerator;
import org.opentestsystem.ap.common.util.SecurityUtil;
import org.opentestsystem.ap.ivs.IvsProperties;
import org.opentestsystem.ap.ivs.models.ErrorReport;
import org.springframework.stereotype.Component;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.stream.Collectors;

import static org.apache.commons.collections4.ListUtils.emptyIfNull;

/**
 * Pulls validation requests from the message broker.
 */
@Slf4j
@Component
public class ValidationService {

    public static final IdGenerator ID_DIGIT_GENERATOR = new RandomIdGenerator(100000, Integer.MAX_VALUE);

    private final ItemRepository itemRepository;

    private final IvsProperties ivsProperties;

    private final SecurityUtil securityUtil;

    private final ValidationUtility validationUtility;

    private final Path localBaseDir;

    public ValidationService(final ItemRepository itemRepository,
                             final IvsProperties ivsProperties,
                             final SecurityUtil securityUtil,
                             final ValidationUtility validationUtility,
                             final ItemBankProperties itemBankProperties) {
        this.itemRepository = itemRepository;
        this.ivsProperties = ivsProperties;
        this.securityUtil = securityUtil;
        this.validationUtility = validationUtility;
        this.localBaseDir = Paths.get(itemBankProperties.getLocalBaseDir());
    }

    // ------------------------------------------------------------------------

    /**
     * Validates an item.
     *
     * @param itemId The item to validate.
     */
    public ValidationResults validateItem(final String itemId) {
        return validateItem(itemId, null);
    }

    public ValidationResults validateItem(final String itemId, final String branchName) {
        log.debug("validateItem: item {}", itemId);

        final ValidationResults result = new ValidationResults();

        GitClient gitClient = null;
        try {
            final Path validationPath = clone(itemId, branchName);
            runValidation(itemId, validationPath);
            result.setValidationResults(emptyIfNull(generateResults(validationPath.getParent())));
        } finally {
            close(gitClient);
        }
        return result;
    }

    public List<ValidationResult> generateResults(final Path reportPath) {
        final List<ErrorReport> errors = validationUtility.parseErrorReport(reportPath);
        return errors.stream()
                .skip(1)
                .filter(error ->
                        !StringUtils.equalsAnyIgnoreCase(
                                error.getCategory(), ivsProperties.getExcludedCategories().toArray(new String[0])))
                .map(this::mapErrorToResult)
                .collect(Collectors.toList());
    }

    // ------------------------------------------------------------------------

    private ValidationResult mapErrorToResult(final ErrorReport error) {
        final ValidationResult result = new ValidationResult();
        result.setItemId(error.getItemId());
        result.setItemType(error.getItemType());
        result.setCategory(error.getCategory());
        result.setDetail(error.getDetail());
        result.setMessage(error.getErrorMessage());
        result.setSeverity(error.getSeverity());
        return result;
    }

    private Path clone(final String itemId, final String branchName) {
        // could be stimulus or assessment item
        final ItemContext itemContext = cloneItem(itemId, branchName);
        return mapToValidationStructure(itemContext);
    }

    /**
     * Clone a specific item branch to the local file system .
     *
     * @param itemId The unique item identifier.
     * @return The context of the cloned item.
     */
    private ItemContext cloneItem(final String itemId, final String branchName) {
        log.debug("cloneItem: item {}", itemId);

        final ItemBankUser user = securityUtil.getItemBankUser();

        final ItemCrudRequest request = itemRepository.buildLookupRequest(user, itemId, branchName);

        final GitClient git = itemRepository.cloneRemoteRepository(user, itemId);
        itemRepository.pullBranch(git, request);
        return git.getItemContext();
    }

    /**
     * Clones a stimulus associated with an item.  If there is no stimulus associated with the item then nothing is
     * cloned and null is returned.
     *
     * @param itemContext The context of an item that may be associated with a stimulus.  The item context is expected
     *                    to reference an AssessmentItem.
     * @return The context of the cloned item.
     */
    private ItemContext cloneItemStimulus(final ItemContext itemContext) {
        final Item item = itemContext.readModelFile();

        ItemContext stimulusContext = null;

        if (!validationUtility.isStim(item)) {
            final String stimulusId = ((AssessmentItem) item).getCore().getStimulusId();
            if (StringUtils.isNotBlank(stimulusId)) {
                final ItemBankUser user = securityUtil.getItemBankUser();
                final GitClient git = itemRepository.cloneRemoteRepository(user, stimulusId);
                stimulusContext = git.getItemContext();
            }
        }

        return stimulusContext;
    }

    /**
     * Shells out and runs the Content Package Tabulator in Error-Only mode to produce a validation.json file for the
     * indicated item.
     *
     * @param itemId The ID of the item to be validated
     * @param path   The path to the folder containing the item
     */
    public void runValidation(String itemId, Path path) {
        log.debug("runValidation: CPT validation for {} in path {}", itemId, path);

        final String command = String.format("%s %s", ivsProperties.getCptExecutablePath(), path.toString());

        BufferedReader stdInput = null;
        try {
            final Process process = Runtime.getRuntime().exec(command);
            logValidationOutput(process);
        } catch (SystemException e) {
            throw e;
        } catch (Exception e) {
            throw new SystemException(e);
        } finally {
            IOUtils.closeQuietly(stdInput);
        }
    }

    // ------------------------------------------------------------------------
    // Helper Methods
    // ------------------------------------------------------------------------

    private Path mapToValidationStructure(final ItemContext itemContext) {
        // random folder, root for the validation request
        final Path validationRootPath = localBaseDir.resolve(ID_DIGIT_GENERATOR.generateTransactionId());
        // root folder has a child folder, typically called 'validation'
        final Path validationRootChild = validationUtility.initializeValidationStructure(validationRootPath);

        // are we dealing with a stim validation request or a assessment item validation request
        final Item item = itemContext.readModelFile();

        // the request is to validate a stimulus
        if (validationUtility.isStim(item)) {
            // maps to "root/validation/Stimuli"
            mapStimulusToValidationStructure(itemContext, validationRootChild);
        } else if (validationUtility.isTutorial(item)) {
            // maps to "root/validation/Items"
            mapTutorialToValidationStructure(itemContext, validationRootChild);
        } else {
            // maps to "root/validation/Items"
            mapItemToValidationStructure(itemContext, validationRootChild);
            // clone the item's associated stimulus
            final ItemContext stimulusContext = cloneItemStimulus(itemContext);
            mapStimulusToValidationStructure(stimulusContext, validationRootChild);
        }
        return validationRootChild;
    }

    private void mapItemToValidationStructure(final ItemContext itemContext, final Path validationRootChild) {
        validationUtility.mapItemToValidationStructure(itemContext, validationRootChild);
        validationUtility.mapGlossaryToValidationStructure(itemContext, validationRootChild);
    }

    private void mapStimulusToValidationStructure(final ItemContext stimulusContext, final Path validationRootChild) {
        validationUtility.mapStimulusToValidationStructure(stimulusContext, validationRootChild);
        // glossary maps to "root/validation/Items", not "Stimuli"
        validationUtility.mapGlossaryToValidationStructure(stimulusContext, validationRootChild);
    }

    private void mapTutorialToValidationStructure(final ItemContext tutorialContext, final Path validationRootChild) {
        validationUtility.mapItemToValidationStructure(tutorialContext, validationRootChild);
    }

    private void close(GitClient gitClient) {
        if (gitClient != null) {
            gitClient.close();
        }
    }

    private void logValidationOutput(final Process process) {
        final BufferedReader stdInput = new BufferedReader(new InputStreamReader(process.getInputStream()));
        String s;
        try {
            while ((s = stdInput.readLine()) != null) {
                log.debug("CPT: {}", s);
            }
        } catch (IOException e) {
            log.warn("logValidationOutput: Error logging validation output.", e);
        }
    }
}
