/*
 * Copyright 2017 Regents of the University of California. Licensed under the Educational Community License, Version
 * 2.0 (the "license"); you may not use this file except in compliance with the License. You may obtain a copy of the
 * license at
 *
 * https://opensource.org/licenses/ECL-2.0
 *
 * Unless required under applicable law or agreed to in writing, software distributed under the License is distributed
 * in an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for
 * specific language governing permissions and limitations under the license.
 */
package org.opentestsystem.ap.ivs.service;

import com.fasterxml.jackson.databind.MappingIterator;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemContext;
import org.opentestsystem.ap.common.repository.RepositoryUtil;
import org.opentestsystem.ap.ivs.IvsProperties;
import org.opentestsystem.ap.ivs.models.ErrorReport;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import static org.opentestsystem.ap.common.model.ItemConstants.ItemType.TYPE_STIM;
import static org.opentestsystem.ap.common.model.ItemConstants.ItemType.TYPE_TUT;

@Slf4j
@Component
public class ValidationUtility {

    private static final String ITEMS_DIR = "Items";

    private static final String STIMULI_DIR = "Stimuli";

    private static final String manifestFile = "imsmanifest.xml";

    private static final String validationRootChildName = "validation";

    private final ItemBankProperties itemBankProperties;

    private final IvsProperties ivsProperties;

    public ValidationUtility(final ItemBankProperties itemBankProperties, final IvsProperties ivsProperties) {
        this.itemBankProperties = itemBankProperties;
        this.ivsProperties = ivsProperties;
    }

    public Path initializeValidationStructure(final Path destinationRootPath) {
        final Path validationRootChild = destinationRootPath.resolve(validationRootChildName);
        try {
            FileUtils.write(validationRootChild.resolve(manifestFile).toFile(), "<manifest/>", "UTF-8");
        } catch (IOException e) {
            throw new SystemException(e);
        }
        return validationRootChild;
    }

    public Path mapItemToValidationStructure(final ItemContext itemContext, final Path validationRootChild) {
        return Objects.nonNull(itemContext) ?
                mapToValidationStructure(itemContext, validationRootChild.resolve(ITEMS_DIR),
                        mapItemFolderName(itemContext.getItemId()))
                : null;
    }

    public Path mapStimulusToValidationStructure(ItemContext stimulusContext, Path validationRootChild) {
        return Objects.nonNull(stimulusContext) ?
                mapToValidationStructure(
                        stimulusContext,
                        validationRootChild.resolve(STIMULI_DIR),
                        mapStimFolderName(stimulusContext.getItemId()))
                : null;
    }

    /**
     * Map an item's local glossary to the validation structure.  The glossary lives in the 'Items' folder.  It sits
     * sibling to other glossaries and items.  Stimulus live in the 'Stimuli' folder.  The item context passed in can be
     * either an item or a stimulus.  The glossary for it is what gets mapped to the validation structure.
     *
     * @param itemContext  An item or stimulus context.
     * @param validationRootChild The root folder of the validation structure.
     * @return
     */
    public Path mapGlossaryToValidationStructure(final ItemContext itemContext, final Path validationRootChild) {
        Path glossaryValidationRepoPath = null;

        if (Objects.nonNull(itemContext)) {
            Item item = itemContext.readModelFile();

            if (item.getGlossary().getTerms().size() > 0) {

                final String glossaryId = RepositoryUtil.getGlossaryId(itemContext.getItemId());

                final String baseName = mapItemFolderName(glossaryId);

                final Path itemsPath = validationRootChild.resolve(ITEMS_DIR);
                glossaryValidationRepoPath = itemsPath.resolve(baseName);

                final Path glossaryValidationFilePath = glossaryValidationRepoPath.resolve(mapFileName(glossaryId));
                try {
                    // copy the item's glossary folder to the local glossary repository folder
                    FileUtils.copyDirectory(itemContext.getLocalGlossaryFolderPath().toFile(), glossaryValidationRepoPath.toFile());

                    // left over from a migration, this file is no longer need
                    // and is removed so it does not negatively affect validation
                    if (glossaryValidationFilePath.toFile().exists()) {
                        glossaryValidationFilePath.toFile().delete();
                    }

                } catch (IOException e) {
                    throw new SystemException("Error mapping glossary " + glossaryId + " to the validation structure", e);
                }
            }
        }

        return glossaryValidationRepoPath;
    }

    public List<ErrorReport> parseErrorReport(final Path reportFolder) {
        final Path errorFilePath = reportFolder.resolve(this.ivsProperties.getErrorReportFileName());
        if (errorFilePath.toFile().exists()) {
            try {
                final MappingIterator<ErrorReport> results =
                        new CsvMapper().readerWithTypedSchemaFor(ErrorReport.class).readValues(errorFilePath.toFile());
                return results.readAll();
            } catch (IOException e) {
                throw new SystemException("Error converting item history list to CSV", e);
            }
        } else {
            return new ArrayList<>();
        }

    }

    public boolean isStim(final Item item) {
        return item != null ? TYPE_STIM.equalsIgnoreCase(item.getType()) : false;
    }

    public boolean isTutorial(final Item item) {
        return Objects.nonNull(item) ? TYPE_TUT.equalsIgnoreCase(item.getType()) : false;
    }

    public void deleteGlossaryDirectory(ItemContext itemContext) {
        if (Objects.nonNull(itemContext)) {
            try {
                Item item = itemContext.readModelFile();
                if (item.getGlossary().getTerms().size() == 0) {
                    FileUtils.deleteDirectory(itemContext.getLocalGlossaryFolderPath().toFile());
                }
            } catch (IOException ex) {
                log.error(String.format("Clone item from preview: Unable to remove 'glossary' directory from item: %s",
                    itemContext.getItemId()));
            }
        }
    }

    // ------------------------------------------------------------------------
    // Helper Methods
    // ------------------------------------------------------------------------

    private Path mapToValidationStructure(final ItemContext itemContext, final Path itemValidationParent, final String baseFolderName) {
        final String itemId = itemContext.getItemId();

        final Path itemValidationRepoPath = itemValidationParent.resolve(baseFolderName);

        final Path itemValidationFilePath = itemValidationRepoPath.resolve(mapFileName(itemId));

        try {
            FileUtils.copyDirectory(itemContext.getLocalRepositoryPath().toFile(), itemValidationRepoPath.toFile());
            RepositoryUtil.deleteDirectory(itemValidationRepoPath.resolve(RepositoryUtil.GLOSSARY_FOLDER_NAME));
            
            // this file may not exist, we renamed project and their respective SAAIF xml file
            // we are deleting the old if it exists to ensure it doesn't negatively affect validation
            if (itemValidationFilePath.toFile().exists()) {
                itemValidationFilePath.toFile().delete();
            }
        } catch (IOException e) {
            throw new SystemException("Error copying item " + itemId + " for validation", e);
        }
        return itemValidationRepoPath;
    }

    private String mapItemFolderName(final String itemId) {
        return String.format("item-%s-%s", this.itemBankProperties.getBankKey(), itemId);
    }

    private String mapStimFolderName(final String itemId) {
        return String.format("stim-%s-%s", this.itemBankProperties.getBankKey(), itemId);
    }

    private String mapFileName(final String baseName) {
        return String.format("%s.xml", baseName);
    }
}
