package org.opentestsystem.ap.ivs.service;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import com.fasterxml.jackson.databind.MappingIterator;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import com.fasterxml.jackson.dataformat.csv.CsvSchema;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemBankUser;
import org.opentestsystem.ap.common.model.ValidationError;
import org.opentestsystem.ap.common.repository.ItemRepository;
import org.opentestsystem.ap.common.util.ValidationException;
import org.opentestsystem.ap.ivs.config.IvsProperties;
import org.springframework.stereotype.Component;

/**
 * Pulls validation requests from the message broker.
 */
@Slf4j
@Component
public class ValidationConsumerService {

    private static String ITEM_ID_REQUIRED = "Item ID is required";

    private final ItemRepository itemRepository;
    private final ItemBankProperties itemBankProperties;
    private final ItemBankUser itemBankUser;

    public ValidationConsumerService(final ItemRepository itemRepository,
                                     final ItemBankProperties itemBankProperties,
                                     final IvsProperties ivsProperties) {
        this.itemRepository = itemRepository;
        this.itemBankProperties = itemBankProperties;
        this.itemBankUser = new ItemBankUser(ivsProperties.getSystemUserName(), ivsProperties.getSystemFullName());
    }

    /**
     * Validates the item and saves the results.
     *
     * @param itemId The item to validate.
     */
    public void validateItem(final String itemId) {
        log.debug("Validating item {}", itemId);
        final Path path = itemRepository.cloneItem(itemBankUser, itemId);
        log.debug("Item {} cloned to {}", itemId, path.toString());

        List<ValidationError> errors = Collections.emptyList();

        // TODO - Call CPT API to get a list of validation errors

        itemRepository.saveValidationResults(itemBankUser, itemId, errors);
    }

    /**
     * Retrieve validation messages xml document from the item repository, parse the csv document, return
     * list of validation errors to the caller. Returns an empty list if file not found.
     *
     * @param itemId The id of the item to load validation messages for
     */
    public List<ValidationError> getValidationMessages(String itemId) {
        if (StringUtils.isBlank(itemId)) {
            throw new ValidationException(ITEM_ID_REQUIRED);
        }
        log.debug("retrieving validation messages for {}", itemId);

        Item item = itemRepository.findItem(itemBankUser, itemId);
        Path path = itemRepository.cloneItem(itemBankUser, itemId);
        Optional<File> errorFile;
        try {
             errorFile = Files.walk(path, FileVisitOption.FOLLOW_LINKS)
                    .map(Path::toFile)
                    .filter(x -> x.getName().equals(getErrorFileName(item)))
                    .findFirst();
            return errorFile.isPresent() ? unpackCsv(errorFile.get(), itemId) : Collections.emptyList();
        } catch(Exception ex) {
            throw new RuntimeException("Error searching for validation messages", ex);
        }
    }

    /**
     * Generate name of error report csv file based on item information
     *
     * @param item
     */
    private String getErrorFileName(Item item) {
        String filename = item.getType().equals("stim") ?
                "stim" : "item";
        filename = filename + "-";
        filename = filename + itemBankProperties.getBankKey();
        filename = filename + "-";
        filename = filename + item.getId();
        return filename + "_ErrorReport.csv";
    }

    /**
     * Reads the csv error report and maps it to a ValidationError list
     *
     * @param file the csv file to be parsed
     * @param itemId the ID of the item the csv is associated to
     */
    private List<ValidationError> unpackCsv(File file, String itemId) throws IOException {
        log.debug("unpacking csv validation error report for item {} with name {}", itemId, file.getName());
        MappingIterator<ValidationError> mappingIterator = new CsvMapper()
                .readerFor(ValidationError.class)
                .with(CsvSchema.emptySchema().withUseHeader(true))
                .readValues(file);
        return mappingIterator.readAll();
    }
}
