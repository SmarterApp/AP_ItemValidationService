package org.opentestsystem.ap.ivs;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.opentestsystem.ap.common.assembler.AppAssembler;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.itembank.IdGenerator;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.preview.PreviewData;
import org.opentestsystem.ap.common.model.validation.ErrorReport;
import org.opentestsystem.ap.common.model.validation.ValidationResult;
import org.opentestsystem.ap.common.model.validation.ValidationResults;
import org.opentestsystem.ap.common.repository.RepositoryUtil;
import org.opentestsystem.ap.common.saaif.ItemContext;
import org.opentestsystem.ap.common.security.SecurityUtil;
import org.opentestsystem.ap.common.util.RandomIdGenerator;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import static org.apache.commons.collections4.ListUtils.emptyIfNull;

/**
 * Pulls validation requests from the message broker.
 */
@Slf4j
@Service
@Transactional(readOnly = true)
public class ValidationService {

    private static final IdGenerator ID_DIGIT_GENERATOR = new RandomIdGenerator(100000, Integer.MAX_VALUE);

    private final ValidationManager validationManager;

    private final ValidationProperties validationProperties;

    private final SecurityUtil securityUtil;

    private final ValidationUtility validationUtility;

    private final AppAssembler appAssembler;

    private final Path localBaseDir;

    public ValidationService(ValidationManager validationManager,
                             ValidationProperties validationProperties,
                             SecurityUtil securityUtil,
                             ValidationUtility validationUtility,
                             AppAssembler appAssembler,
                             ItemBankProperties itemBankProperties) {
        this.validationManager = validationManager;
        this.validationProperties = validationProperties;
        this.securityUtil = securityUtil;
        this.validationUtility = validationUtility;
        this.appAssembler = appAssembler;
        this.localBaseDir = Paths.get(itemBankProperties.getLocalBaseDir());
    }

    // ------------------------------------------------------------------------

    public ValidationResults validateItem(final String itemId) {
        log.debug("validateItem: item {}", itemId);

        final ValidationResults result = new ValidationResults();

        final Path validationPath = downloadData(itemId);
        runValidation(itemId, validationPath);

        List<ValidationResult> validationResults = generateResults(validationPath.getParent());

        if (this.shouldCleanup()) {
            RepositoryUtil.deleteDirectory(validationPath.getParent());
        }

        ValidationResult syncResult = this.validationManager.generateSyncResult(itemId);

        if (Objects.nonNull(syncResult)) {
            validationResults.add(0, syncResult);
        }

        result.setValidationResults(emptyIfNull(validationResults));

        return result;
    }

    public List<ValidationResult> generateResults(final Path reportPath) {
        final List<ErrorReport> errors = validationUtility.parseErrorReport(reportPath);

        final Set<ValidationResult> errorsWithNoDups = errors.stream()
            .skip(1)
            .filter(error ->
                !StringUtils.equalsAnyIgnoreCase(
                    error.getCategory(), validationProperties.getExcludedCategories().toArray(new String[0])))
            .map(this::mapErrorToResult)
            .collect(Collectors.toSet());

        return new ArrayList<>(errorsWithNoDups);
    }

    // ------------------------------------------------------------------------

    private ValidationResult mapErrorToResult(final ErrorReport error) {
        final ValidationResult result = new ValidationResult();
        result.setItemId(error.getItemId());
        result.setItemType(error.getItemType());
        result.setCategory(error.getCategory());
        result.setDetail(error.getDetail());
        result.setMessage(error.getErrorMessage());
        result.setSeverity(error.getSeverity());
        return result;
    }

    private Path downloadData(final String itemId) {
        PreviewData previewData = this.validationManager.generatePreviewData(securityUtil.getItemBankUser(), itemId);

        // could be stimulus or assessment item
        ItemContext itemContext = new ItemContext(
            itemId,
            previewData.getLegacyItemId(),
            previewData.getBankKey(),
            this.appAssembler,
            previewData.getRepositoryPath()
        );

        validationUtility.deleteGlossaryDirectory(itemContext);

        ItemContext stimulusContext = null;

        if (Objects.nonNull(previewData.getStimulusId())) {
            stimulusContext = new ItemContext(
                previewData.getStimulusId(),
                previewData.getLegacyStimulusId(),
                previewData.getBankKey(),
                this.appAssembler,
                previewData.getRepositoryPath().getParent().resolve(previewData.getLegacyStimulusId())
            );
        }

        return mapToValidationStructure(itemContext, stimulusContext);
    }

    /**
     * Shells out and runs the Content Package Tabulator in Error-Only mode to produce a validation.json file for the
     * indicated item.
     *
     * @param itemId The ID of the item to be validated
     * @param path   The path to the folder containing the item
     */
    public void runValidation(String itemId, Path path) {
        log.debug("runValidation: CPT validation for {} in path {}", itemId, path);
        final String command = String.format("%s %s", validationProperties.getCptExecutablePath(), path.toString());
        try {
            final Process process = Runtime.getRuntime().exec(command);
            logValidationOutput(process);
        } catch (SystemException e) {
            throw e;
        } catch (Exception e) {
            throw new SystemException(e);
        }
    }

    // ------------------------------------------------------------------------
    // Helper Methods
    // ------------------------------------------------------------------------

    private Path mapToValidationStructure(final ItemContext itemContext, final ItemContext stimulusContext) {
        // random folder, root for the validation request
        final Path validationRootPath = localBaseDir.resolve(ID_DIGIT_GENERATOR.generateTransactionId());
        // root folder has a child folder, typically called 'validation'
        final Path validationRootChild = validationUtility.initializeValidationStructure(validationRootPath);

        // are we dealing with a stim validation request or a assessment item validation request
        final Item item = itemContext.readModelFile();

        // the request is to validate a stimulus
        if (item.isStimulus()) {
            // maps to "root/validation/Stimuli"
            mapStimulusToValidationStructure(itemContext, validationRootChild);
        } else if (item.isTutorial()) {
            // maps to "root/validation/Items"
            mapTutorialToValidationStructure(itemContext, validationRootChild);
        } else {
            // maps to "root/validation/Items"
            mapItemToValidationStructure(itemContext, validationRootChild);
            // downloadData the item's associated stimulus
            validationUtility.deleteGlossaryDirectory(stimulusContext);
            mapStimulusToValidationStructure(stimulusContext, validationRootChild);
        }

        // clean up immediately, don't wait for cleanup task every few minutes, when
        // validation usage spikes waiting for the cleanup task is not enough, the disk
        // still fills up and the pod is evicted
        RepositoryUtil.deleteDirectory(itemContext.getLocalRepositoryPath().getParent());

        return validationRootChild;
    }

    private void mapItemToValidationStructure(final ItemContext itemContext, final Path validationRootChild) {
        validationUtility.mapItemToValidationStructure(itemContext, validationRootChild);
        validationUtility.mapGlossaryToValidationStructure(itemContext, validationRootChild);
    }

    private void mapStimulusToValidationStructure(final ItemContext stimulusContext, final Path validationRootChild) {
        validationUtility.mapStimulusToValidationStructure(stimulusContext, validationRootChild);
        // glossary maps to "root/validation/Items", not "Stimuli"
        validationUtility.mapGlossaryToValidationStructure(stimulusContext, validationRootChild);
    }

    private void mapTutorialToValidationStructure(final ItemContext tutorialContext, final Path validationRootChild) {
        validationUtility.mapItemToValidationStructure(tutorialContext, validationRootChild);
    }

    private void logValidationOutput(final Process process) {
        final BufferedReader stdInput = new BufferedReader(new InputStreamReader(process.getInputStream()));
        String s;
        try {
            while ((s = stdInput.readLine()) != null) {
                log.debug("CPT: {}", s);
            }
        } catch (IOException e) {
            log.warn("logValidationOutput: Error logging validation output.", e);
        }
    }

    /**
     * @return True if the application is configured to immediately cleanup after validating an item.  False is cleanup
     * is handled by the scheduled task.
     */
    private boolean shouldCleanup() {
        return !this.validationProperties.isDisableImmediateCleanup();
    }
}
