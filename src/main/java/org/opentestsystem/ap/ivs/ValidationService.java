package org.opentestsystem.ap.ivs;

import com.fasterxml.jackson.databind.MappingIterator;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.itembank.IdGenerator;
import org.opentestsystem.ap.common.model.validation.ErrorReport;
import org.opentestsystem.ap.common.model.validation.ValidationResult;
import org.opentestsystem.ap.common.model.validation.ValidationResults;
import org.opentestsystem.ap.common.repository.RepositoryUtil;
import org.opentestsystem.ap.common.security.SecurityUtil;
import org.opentestsystem.ap.common.util.RandomIdGenerator;
import org.opentestsystem.ap.ivs.generation.ItemDataGenerationService;
import org.opentestsystem.ap.ivs.model.ValidationGenerationInformation;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import static org.apache.commons.collections4.ListUtils.emptyIfNull;

/**
 * Pulls validation requests from the message broker.
 */
@Slf4j
@Service
@Transactional(readOnly = true)
public class ValidationService {

    private static final IdGenerator ID_DIGIT_GENERATOR = new RandomIdGenerator(100000, Integer.MAX_VALUE);

    private final ValidationManager validationManager;

    private final ValidationProperties validationProperties;

    private final Path localBaseDir;

    private final ItemDataGenerationService itemDataGenerationService;

    public ValidationService(ValidationManager validationManager,
                             ValidationProperties validationProperties,
                             ItemBankProperties itemBankProperties,
                             final ItemDataGenerationService itemDataGenerationService) {
        this.validationManager = validationManager;
        this.validationProperties = validationProperties;
        this.localBaseDir = Paths.get(itemBankProperties.getLocalBaseDir());
        this.itemDataGenerationService = itemDataGenerationService;
    }

    // ------------------------------------------------------------------------

    public ValidationResults validateItem(final String itemId) {
        log.debug("validateItem: item {}", itemId);

        final ValidationResults result = new ValidationResults();

        final Path rootItemValidationPath = createItemValidationFolder();

        final ValidationGenerationInformation info = itemDataGenerationService
            .generateItemData(SecurityUtil.getItemBankUser(), itemId, rootItemValidationPath);

        runValidation(itemId, info.getValidationPath());

        List<ValidationResult> validationResults = generateResults(rootItemValidationPath);

        if (this.shouldCleanup()) {
            RepositoryUtil.deleteDirectory(rootItemValidationPath);
        }

        ValidationResult syncResult = this.validationManager.generateSyncResult(itemId);

        if (Objects.nonNull(syncResult)) {
            validationResults.add(0, syncResult);
        }

        result.setValidationResults(emptyIfNull(validationResults));

        return result;
    }

    public List<ValidationResult> generateResults(final Path reportPath) {
        final List<ErrorReport> errors = parseErrorReport(reportPath);

        final Set<ValidationResult> errorsWithNoDups = errors.stream()
            .skip(1)
            .filter(error ->
                !StringUtils.equalsAnyIgnoreCase(
                    error.getCategory(), validationProperties.getExcludedCategories().toArray(new String[0])))
            .map(this::mapErrorToResult)
            .collect(Collectors.toSet());

        return new ArrayList<>(errorsWithNoDups);
    }

    // ------------------------------------------------------------------------

    private ValidationResult mapErrorToResult(final ErrorReport error) {
        final ValidationResult result = new ValidationResult();
        result.setItemId(error.getItemId());
        result.setItemType(error.getItemType());
        result.setCategory(error.getCategory());
        result.setDetail(error.getDetail());
        result.setMessage(error.getErrorMessage());
        result.setSeverity(error.getSeverity());
        return result;
    }

    /**
     * Shells out and runs the Content Package Tabulator in Error-Only mode to produce a validation.json file for the
     * indicated item.
     *
     * @param itemId The ID of the item to be validated
     * @param path   The path to the folder containing the item
     */
    public void runValidation(String itemId, Path path) {
        log.debug("runValidation: CPT validation for {} in path {}", itemId, path);
        final String command = String.format("%s %s", validationProperties.getCptExecutablePath(), path.toString());
        try {
            final Process process = Runtime.getRuntime().exec(command);
            logValidationOutput(process);
        } catch (SystemException e) {
            throw e;
        } catch (Exception e) {
            throw new SystemException(e);
        }
    }

    private void logValidationOutput(final Process process) {
        final BufferedReader stdInput = new BufferedReader(new InputStreamReader(process.getInputStream()));
        String s;
        try {
            while ((s = stdInput.readLine()) != null) {
                log.debug("CPT: {}", s);
            }
        } catch (IOException e) {
            log.warn("logValidationOutput: Error logging validation output.", e);
        }
    }

    /**
     * @return True if the application is configured to immediately cleanup after validating an item.  False is cleanup
     * is handled by the scheduled task.
     */
    private boolean shouldCleanup() {
        return !this.validationProperties.isDisableImmediateCleanup();
    }

    private Path createItemValidationFolder() {
        Path path = localBaseDir.resolve(UUID.randomUUID().toString());
        try {
            return Files.createDirectories(path);
        } catch (IOException e) {
            throw new SystemException("Unable to create base validation directory structure " + path);
        }
    }

    private List<ErrorReport> parseErrorReport(final Path reportFolder) {
        final Path errorFilePath = reportFolder.resolve(this.validationProperties.getErrorReportFileName());
        if (errorFilePath.toFile().exists()) {
            try {
                final MappingIterator<ErrorReport> results =
                    new CsvMapper().readerWithTypedSchemaFor(ErrorReport.class).readValues(errorFilePath.toFile());
                return results.readAll();
            } catch (IOException e) {
                throw new SystemException("Error converting item history list to CSV", e);
            }
        } else {
            return new ArrayList<>();
        }

    }
}
