/*
 * Copyright 2017 Regents of the University of California. Licensed under the Educational Community License, Version
 * 2.0 (the "license"); you may not use this file except in compliance with the License. You may obtain a copy of the
 * license at
 *
 * https://opensource.org/licenses/ECL-2.0
 *
 * Unless required under applicable law or agreed to in writing, software distributed under the License is distributed
 * in an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for
 * specific language governing permissions and limitations under the license.
 */
package org.opentestsystem.ap.ivs;

import com.fasterxml.jackson.databind.MappingIterator;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.model.validation.ErrorReport;
import org.opentestsystem.ap.common.repository.RepositoryUtil;
import org.opentestsystem.ap.common.saaif.ItemContext;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@Slf4j
public class ValidationUtility {

    private static final String ITEMS_DIR = "Items";

    private static final String STIMULI_DIR = "Stimuli";

    private static final String manifestFile = "imsmanifest.xml";

    private static final String validationRootChildName = "validation";

    private final ValidationProperties validationProperties;

    public ValidationUtility(final ValidationProperties validationProperties) {
        this.validationProperties = validationProperties;
    }

    public Path initializeValidationStructure(final Path destinationRootPath) {
        final Path validationRootChild = destinationRootPath.resolve(validationRootChildName);
        try {
            FileUtils.write(validationRootChild.resolve(manifestFile).toFile(), "<manifest/>", "UTF-8");
        } catch (IOException e) {
            throw new SystemException(e);
        }
        return validationRootChild;
    }

    public Path mapItemToValidationStructure(final ItemContext itemContext, final Path validationRootChild) {
        return Objects.nonNull(itemContext) ?
            mapToValidationStructure(itemContext, validationRootChild.resolve(ITEMS_DIR), itemContext.getLegacyId())
            : null;
    }

    public Path mapStimulusToValidationStructure(ItemContext stimulusContext, Path validationRootChild) {
        return Objects.nonNull(stimulusContext) ?
            mapToValidationStructure(
                stimulusContext, validationRootChild.resolve(STIMULI_DIR), stimulusContext.getLegacyId())
            : null;
    }

    /**
     * This method expects the item and it's glossary are on disk in the same folder.  Item and glossary are sibling
     * folders.  The glossary folder is copied to the validation structure.
     *
     * @param itemContext         An item or stimulus context.
     * @param validationRootChild The root folder of the validation structure.
     * @return
     */
    public Path mapGlossaryToValidationStructure(final ItemContext itemContext, final Path validationRootChild) {
        Path glossaryValidationRepoPath = null;

        if (Objects.nonNull(itemContext)) {
            String glossaryLegacyId = itemContext.getGlossaryLegacyId();

            // it is expected the glossary repo is a sibling with the item repo
            Path glossaryRepoPath = itemContext.getLocalRepositoryPath().getParent().resolve(glossaryLegacyId);

            if (Files.exists(glossaryRepoPath)) {
                Path itemsPath = validationRootChild.resolve(ITEMS_DIR);
                glossaryValidationRepoPath = itemsPath.resolve(glossaryLegacyId);

                try {
                    // copy the glossary folder to the validation folder structure
                    FileUtils.copyDirectory(glossaryRepoPath.toFile(), glossaryValidationRepoPath.toFile());
                } catch (IOException e) {
                    throw new SystemException(
                        "Error mapping glossary " + itemContext.getGlossaryId() + " to the validation structure",
                        e);
                }
            }
        }

        return glossaryValidationRepoPath;
    }

    public List<ErrorReport> parseErrorReport(final Path reportFolder) {
        final Path errorFilePath = reportFolder.resolve(this.validationProperties.getErrorReportFileName());
        if (errorFilePath.toFile().exists()) {
            try {
                final MappingIterator<ErrorReport> results =
                    new CsvMapper().readerWithTypedSchemaFor(ErrorReport.class).readValues(errorFilePath.toFile());
                return results.readAll();
            } catch (IOException e) {
                throw new SystemException("Error converting item history list to CSV", e);
            }
        } else {
            return new ArrayList<>();
        }

    }

    public void deleteGlossaryDirectory(ItemContext itemContext) {
        if (Objects.nonNull(itemContext)) {
            try {
                if (Files.exists(itemContext.getLocalGlossaryFolderPath())) {
                    FileUtils.deleteDirectory(itemContext.getLocalGlossaryFolderPath().toFile());
                }
            } catch (IOException ex) {
                log.error(String.format("Clone item from preview: Unable to remove 'glossary' directory from item: %s",
                    itemContext.getItemId()));
            }
        }
    }

    // ------------------------------------------------------------------------
    // Helper Methods
    // ------------------------------------------------------------------------

    private Path mapToValidationStructure(final ItemContext itemContext,
                                          final Path itemValidationParent,
                                          final String baseFolderName) {
        final String itemId = itemContext.getItemId();

        final Path itemValidationRepoPath = itemValidationParent.resolve(baseFolderName);

        final Path oldItemSaaifFilePath = itemValidationRepoPath.resolve(String.format("%s.xml", itemId));

        try {
            FileUtils.copyDirectory(itemContext.getLocalRepositoryPath().toFile(), itemValidationRepoPath.toFile());
            RepositoryUtil.deleteDirectory(itemValidationRepoPath.resolve(RepositoryUtil.GLOSSARY_FOLDER_NAME));

            // this file may not exist, we renamed project and their respective SAAIF xml file
            // we are deleting the old if it exists to ensure it doesn't negatively affect validation
            if (Files.exists(oldItemSaaifFilePath)) {
                Files.delete(oldItemSaaifFilePath);
            }
        } catch (IOException e) {
            throw new SystemException("Error copying item " + itemId + " for validation", e);
        }
        return itemValidationRepoPath;
    }
}
